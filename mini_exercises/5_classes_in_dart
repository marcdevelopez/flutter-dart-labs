// NOTA IMPORTANTE:
// En un proyecto real en Dart o Flutter, lo correcto sería separar cada clase en su propio archivo
// dentro de una estructura de carpetas organizada (por ejemplo: models/, utils/, etc.).
// Sin embargo, como este es un mini proyecto educativo y estamos en una etapa temprana del curso,
// se ha decidido colocar todo en un solo archivo para facilitar la comprensión y práctica de los
// conceptos fundamentales de clases, objetos, métodos, encapsulamiento, herencia, etc.
// Esta simplificación permite enfocarnos en aprender sin complicar la estructura innecesariamente.

void main() {
    // Aquí comenzará la simulación del zoológico
}

// --------------------------- CLASES ---------------------------

// Clase base para representar un animal
class Animal {
    // Propiedades comunes a todos los animales
    String name;
    int age;

    // Propiedad privada (solo accesible dentro de esta clase)
    final String _species;

    // Constructor para inicializar las propiedades
    Animal(this.name, this.age, this._species);
    
    // Método que representa un comportamiento comun a esta clase Animal
    // Este método puede ser sobrescrito por las clases hijas
    void makeSound() {
        print('$name makes a generic animalsound.');
    }

    // Getter para acceder a la especie (no permite que se modifique directamente sin usar getter)
    String get species => _species;

    // Getter para calcular años hasta ser considerado viejo (valor arbitrario de 15)
    int get yearsUntilOld => 15 - age;
}

// Clase Dog que hereda de Animal
class Dog extends Animal {
    // Constructor: pasa los valores al constructor de la clase base Animal
    // Con los dos puntos (:) indicamos que estamos llamando al constructor de la clase padre
    // El tercer parámetro es fijo para esta clase, ya que todos los perros son de la especie 'Dog'
    Dog(String name, int age) : super(name, age, 'Dog');

    // Método sobrescrito (requiere anotación @override): hace un sonido específico para perros
    @override
    void makeSound() {
        print('$name barks: Woof! Woof!');
    }

    // Método adicional específico para perros, que no está en la clase base Animal
    void fetch() {
        print('$name is fetching the ball!');
    }
}

// Clase Cat que hereda de Animal
class Cat extends Animal {
    // Esatdo interno privado que representa el animo del gato
    double _mood = 5.0; // Valor entre 0 y 10

    // Constructor que inicializa con 'Cat' como especie fija
    Cat(String name, int age) : super(name, age, 'Cat');

    // Sobrescribe el sonido que hace el gato
    @override
    void makeSound() {
        print('$name meows: Miau! Miau!');
    }

    // Método personalizado que incrementa el ánimo del gato
    void play() {
        _mood += 1.0;
    }

    // Getter para consultar el estado de ánimo del gato
    double get mood => _mood;

    // Setter que permite ajustar el estado de ánimo del gato con validación
    set mood(double value) {
        if (value >= 0 && value <= 10) {
            _mood = value;
        }
        
    }
}

// Clase ZooKeeper (guarda del zoológico)
// Esta clase no necesita ser instanciada porque solo contiene métodos utilitarios (métodos estáticos)
// que operan sobre listas de animales - por esos usaremos dos métodos estáticos.
class ZooKeeper {
    // Métopdo estático que simula alimentar a cada animal de una lista
    static void feedAnimals(List<Animal> animals) {
        // forEach recorre cada elemento de la lista "animals"
        // La funcioón anínima recibe cada animal y ejecuta el cuerpo con él
        animals.forEach((animal) {
        // Accde a las propiedades públicas de cada animal
        print('Feeding ${animal.name} the ${animal.species}.');
        });
     }
         
     // Método estático que pide a cada animal que haga su sonido
     static void soundCheck(List<Animal> animals) {
        // También usamos forEach con una función anónima en una sola línea
        animals.forEach((animal) => animal.makeSound());
     }

}
